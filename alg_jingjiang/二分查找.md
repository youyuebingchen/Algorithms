# 二分搜索
attention：mid=(left+right)/2 当下标过大时可能产生溢出。<br/>
更安全的写法：mid = left+(right-left)/2
## 应用场景
### 在有序序列中查找一个数，时间复杂度为O(logN)
## 二分搜索常见的考察点
#### 二分搜索常见的题目变化

- 给定处理或查找的对象不同（如有无重复）
- 判断条件不同
- 要求返回的内容不同
#### 在有序循环数组中进行二分搜索
# 案例
##例一
	给定一个无序数组，一直任意相邻的两个元素值都不重复，请返回任意一个局部最小值的位置。（二分搜索并不一定在有序数组上才能用）

- 如果list是空或者长度为0返回Fasle
- 如果长度为1返回0
- 如果长度大于1，先判断两边位置关系如果两边有小的返回来。<br/>
  如果两边的都是大，则看mid如果mid两端的数都比mid大返回mid,否则对两端中值减小的方向再进行二分查找
##例二
	给定一个有序数组list，再给定一个整数num，请在list中找到num这个数出现的最左边的位置。[1,2,3.3,3,4,4,4,4,4,4,4]
- 先生成全局变量 res = -1 用来记录最后出现num的位置
- 在找到的数后继续向左或者向右进行查找遇到再更新
##例三
	给定一个有序循环数组list，返回list中的最小值。
- 先看list left 是否小于right如果小于则说明是有序数组直接返回left
- 如果list[left] >= list[right]说明是循环数组，比较两边和mid之间的大小，对不同部分进行查找
- 如果list[left]<=list[mid] 且list[right]<=list[mid]
- 如果list[left] = list[mid] = list[right]则进行遍历
##例四   
	给定一个有序数组list，其中不含有重复元素，请找出满足list[i]==i的最左边的位置，如果不满足返回 false
- 给定变量res = -1记录位置
- 如果list[0]>n-1则返回Fasle
- 如果 list[n-1] <0 则返回Fasle
- 剩下的进行二分，如果list[mid]>mid在0-mid上继续进行二分
- 如果list[mid]==mid则几下res = mid 然后在左边继续搜索。
##例五
	给定一颗完全二叉树的头节点kead，返回这个数的节点个数，如果完全二叉树的节点数为N，请事先时间复杂度低于O(n)的解法
- 找最大深度
- 用公式计算满树的节点数
##例六
	如何更快的求一个整数的n次方。如果两个整数相乘并得到结果的时间复杂度为O(1),得到整数k的n次方的过程请事先时间复杂度为O(logn)的方法。
- 将指数变成二进制形式为1的部分相乘，为零的部分去掉，从小到大一次计算相乘

 
